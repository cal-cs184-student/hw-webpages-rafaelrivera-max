<html>
	<head>
		<script src='https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.4/MathJax.js?config=default'></script>
		<link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600&display=swap" rel="stylesheet">
		<style>
			h1 {
				text-align: center;
			}

			.container {
				margin: 0 auto;
				padding: 60px 20%;
			}

			figure {
				text-align: center;
			}

			img {
				display: inline-block;
			}

			body {
				font-family: 'Inter', sans-serif;
			}
		</style>
	</head>
	<body>
		<div class="container">
		<h1>CS184/284A Spring 2025 Homework 1 Write-Up</h1>
		<div style="text-align: center;">Names: </div>

		<br>

		Link to webpage: (TODO) <a href="https://cs184.eecs.berkeley.edu/sp25">cs184.eecs.berkeley.edu/sp25</a>
		
		<br>

		Link to GitHub repository: (TODO) <a href="https://cs184.eecs.berkeley.edu/sp25">cs184.eecs.berkeley.edu/sp25</a>

		<figure>
			<img src="images/lion.jpg" alt="Lion" style="width:50%"/>
			<figcaption>You can add images with captions!</figcaption>
		</figure>

		<!--
		We've already added one heading per task, to make your write-up as navigable when grading. Please fit your write-up within these sections!
		-->

		<h2>Overview</h2>
		For this homework I built a mini rasterizer end‑to‑end: triangle coverage, supersampling antialiasing, color interpolation, texture sampling, and mipmapping. The most interesting part was seeing how small math choices (sample location, edge tests, UV derivatives) immediately show up in image quality. Putting all of the pieces together felt like assembling a tiny graphics pipeline from scratch.

		<h2>Task 1: Drawing Single-Color Triangles</h2>
		I compute the axis‑aligned bounding box of each triangle, clamp it to the framebuffer, and only iterate over pixels inside that box. For each pixel, I test the sample at the pixel center (x + 0.5, y + 0.5) using edge‑function/barycentric checks. If the point is inside or on an edge, I fill the pixel. This works regardless of vertex winding order.
		<br><br>
		This algorithm is no worse than checking every sample in the bounding box, because it only iterates over that box and skips everything outside it.

		<p>Here is an example 2x2 gridlike structure using an HTML table. Each <b>tr</b> is a row and each <b>td</b> is a column in that row. You might find this useful for framing and showing your result images in an organized fashion.</p>
		<div style="display: flex; flex-direction: column; align-items: center;">
			<table style="width: 100%; text-align: center; border-collapse: collapse;">
			  <tr>
				<td style="text-align: center;">
				  <img src="images/task1_test4.png" width="400px"/>
				  <figcaption>Task 1: basic/test4.svg (default view, pixel inspector on edge).</figcaption>
				</td>
				<td style="text-align: center;">
				  <img src="images/task2_spp1.png" width="400px"/>
				  <figcaption>Task 2: 1 spp (same inspector spot).</figcaption>
				</td>
			  </tr>
			  <tr>
				<td style="text-align: center;">
				  <img src="images/task2_spp4.png" width="400px"/>
				  <figcaption>Task 2: 4 spp (same inspector spot).</figcaption>
				</td>
				<td style="text-align: center;">
				  <img src="images/task2_spp16.png" width="400px"/>
				  <figcaption>Task 2: 16 spp (same inspector spot).</figcaption>
				</td>
			  </tr>
			</table>
		</div>
		
		<h2>Task 2: Antialiasing by Supersampling</h2>
		I implemented supersampling by storing multiple sub‑pixel samples per pixel in a supersample buffer. During rasterization, I test each sub‑pixel sample and write into the buffer. In resolve, I average the samples back into a single framebuffer color.
		<br><br>
		Supersampling helps because it captures partial coverage within a pixel. Thin edges and skinny triangles stop “snapping” to single pixels, so aliasing and jaggies are reduced. The improvements are very clear at 4× and 16×.

		<h2>Task 3: Transforms</h2>
		I modified the cubeman to make him wave by rotating and bending his right arm while keeping the rest of the body stable. The goal was a clean, readable gesture without changing proportions too much.
		<figure>
			<img src="images/task3_my_robot.png" alt="My Robot" style="width:60%"/>
			<figcaption>Waving cubeman (docs/my_robot.svg).</figcaption>
		</figure>

		<h2>Task 4: Barycentric coordinates</h2>
		Barycentric coordinates represent any point inside a triangle as a weighted blend of the three vertices, where the weights sum to 1. This makes them perfect for smooth color interpolation and texture mapping across a triangle.
		<figure>
			<img src="images/task4_test7.png" alt="test7" style="width:60%"/>
			<figcaption>basic/test7.svg (sample rate 1).</figcaption>
		</figure>

		<h2>Task 5: "Pixel sampling" for texture mapping</h2>
		Pixel sampling determines how we fetch a texel for a given UV coordinate. Nearest picks the closest texel, while bilinear blends the surrounding four texels. Nearest is sharper but blockier; bilinear is smoother, especially at oblique angles or minification. Supersampling helps both, but bilinear still looks cleaner overall.
		<div style="display: flex; flex-direction: column; align-items: center;">
			<table style="width: 100%; text-align: center; border-collapse: collapse;">
			  <tr>
				<td style="text-align: center;">
				  <img src="images/task5_nearest_1.png" width="400px"/>
				  <figcaption>P_NEAREST, 1 spp.</figcaption>
				</td>
				<td style="text-align: center;">
				  <img src="images/task5_nearest_16.png" width="400px"/>
				  <figcaption>P_NEAREST, 16 spp.</figcaption>
				</td>
			  </tr>
			  <tr>
				<td style="text-align: center;">
				  <img src="images/task5_linear_1.png" width="400px"/>
				  <figcaption>P_LINEAR, 1 spp.</figcaption>
				</td>
				<td style="text-align: center;">
				  <img src="images/task5_linear_16.png" width="400px"/>
				  <figcaption>P_LINEAR, 16 spp.</figcaption>
				</td>
			  </tr>
			</table>
		</div>

		<h2>Task 6: "Level Sampling" with mipmaps for texture mapping</h2>
		Level sampling chooses which mipmap level to use based on the pixel’s footprint in texture space. L_ZERO always uses level 0, while L_NEAREST chooses the closest mip level. Mipmaps reduce aliasing when textures are minified and generally improve temporal stability, but they cost extra memory. P_NEAREST vs P_LINEAR still controls how texels are filtered within the chosen mip level.
		<div style="display: flex; flex-direction: column; align-items: center;">
			<table style="width: 100%; text-align: center; border-collapse: collapse;">
			  <tr>
				<td style="text-align: center;">
				  <img src="images/task6_l0_pn.png" width="400px"/>
				  <figcaption>L_ZERO + P_NEAREST.</figcaption>
				</td>
				<td style="text-align: center;">
				  <img src="images/task6_l0_pl.png" width="400px"/>
				  <figcaption>L_ZERO + P_LINEAR.</figcaption>
				</td>
			  </tr>
			  <tr>
				<td style="text-align: center;">
				  <img src="images/task6_ln_pn.png" width="400px"/>
				  <figcaption>L_NEAREST + P_NEAREST.</figcaption>
				</td>
				<td style="text-align: center;">
				  <img src="images/task6_ln_pl.png" width="400px"/>
				  <figcaption>L_NEAREST + P_LINEAR.</figcaption>
				</td>
			  </tr>
			</table>
		</div>

		<h2>(Optional) Task 7: Extra Credit - Draw Something Creative!</h2>
		If you include this section, add your competition SVG screenshot(s) here and describe the concept + implementation.

		<h2>Additional Notes (please remove)</h2>
		<ul>
			<li>You can also add code if you'd like as so: <code>code code code</code></li>
			<li>If you'd like to add math equations, 
				<ul>
					<li>You can write inline equations like so: \( a^2 + b^2 = c^2 \)</li>
					<li>You can write display equations like so: \[ a^2 + b^2 = c^2 \]</li>
				</ul>
			</li>
		</ul>
		</div>
	</body>
</html>

